<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang=""><head>
    <meta charset="utf-8">
    <meta name="generator" content="pandoc">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <meta name="author" content="Laboratório de Algoritmia I">
    <meta name="author" content="Laboratórios de Informática II">
    <meta name="author" content="Ano letivo 2019/20">
    <title>Guião da aula 5</title>
    <style>
        code{white-space: pre-wrap;}
        span.smallcaps{font-variant: small-caps;}
        span.underline{text-decoration: underline;}
        div.column{display: inline-block; vertical-align: top; width: 50%;}
        div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
        ul.task-list{list-style: none;}
    </style>
    <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
    <![endif]-->
</head>
<body>
<header id="title-block-header">
    <h1 class="title">Guião da aula 5</h1>
    <p class="author">Laboratório de Algoritmia I</p>
    <p class="author">Laboratórios de Informática II</p>
    <p class="author">Ano letivo 2019/20</p>
</header>
<h1 id="tarefas-a-executar-esta-semana">Tarefas a executar esta semana</h1>
<p>Devido ao despacho RT-23/2020, não há aulas esta semana. Mas pretende-se que os alunos trabalhem em regime de ensino à distância. Assim, pretende-se que:</p>
<ul>
    <li>Os alunos que ainda não o fizeram, deverão enviar um email ao docente do seu turno prático com a constituição do grupo até ao dia <strong>10 de Março</strong>;</li>
    <li>Será publicada a lista dos números dos grupos;</li>
    <li>Até ao dia <strong>13 de Março às 20:00</strong>, os alunos deverão submeter na plataforma <strong>Blackboard</strong> o resultado do seu trabalho da semana na forma de um link para o <strong>Github</strong> com o código correspondente ao trabalho que desenvolveram ao longo da semana. O projeto deverá ter não só o código mas também um pequeno resumo do trabalho efetuado e das dificuldades encontradas;</li>
    <li>Este link deverá ser mantido com as alterações que cada grupo faça ao seu projeto ao longo do semestre;</li>
    <li>A avaliação do acompanhamento será efetuada através da submissão do link do Github;</li>
    <li>Foi criado um fórum de discussão na plataforma <strong>Blackboard</strong> para dúvidas que possam surgir.</li>
</ul>
<p>Esta semana pretende-se que:</p>
<ol type="1">
    <li>Se criem os vários módulos;</li>
    <li>Se implemente a função que inicializa o estado do jogo;</li>
    <li>Se implemente a função que mostra o tabuleiro com a jogada efetuada;</li>
    <li>Se implemente a função que coloca uma peça branca na casa jogada (ainda sem validar se a jogada é válida ou colocar uma peça preta no local atual da peça branca).</li>
</ol>
<h1 id="github">Github</h1>
<p>Há muitos tutoriais na net, por exemplo: <a href="https://guides.github.com/activities/hello-world/">https://guides.github.com/activities/hello-world/</a>. O objetivo da equipa docente é que cada grupo crie o repositório para o seu projeto e que faça <em>commits</em>. Como pretendemos avaliar a vossa prestação, incluimos as seguintes regras:</p>
<ul>
    <li>Cada elemento deverá criar um utilizador com o <strong>nome completo</strong>.</li>
    <li>A página de rosto do projeto deve indicar:
        <ul>
            <li>o nome da <strong>UC</strong>;</li>
            <li>o turno prático;</li>
            <li>o número do grupo;</li>
            <li>o número de aluno e nome completo de cada elemento do grupo;</li>
        </ul></li>
    <li>Cada vez que o código seja modificado, o <strong>autor dessa modificação</strong> deverá fazer um <em>commit</em> dessas alterações;</li>
    <li>A avaliação de cada elemento do grupo será de acordo com os <em>commits</em> efetuados;</li>
</ul>
<h1 id="plágio">Plágio</h1>
<p>Ao colocar o código num repositório público, é sempre possível que alguém possa copiar o código de outro projeto. De acordo com o código de ética da Universidade do Minho, tal ação é considerada plágio. Caso haja dúvida em relação a plágio, a equipa docente irá utilizar informação sobre os <em>commits</em> para decidir quem produziu o código e quem o copiou. Caso a equipa docente decida que houve plágio, os grupos que sejam considerados autores de plágio terão <strong>ZERO</strong> na componente de projeto.</p>
<h1 id="estruturação">Estruturação</h1>
<p>Pretende-se que o projeto seja estruturado em três camadas:</p>
<ul>
    <li>Camada de dados</li>
    <li>Lógica do programa</li>
    <li>Camada de interface</li>
</ul>
<p>Cada camada deverá corresponder a um ou mais módulos. Relembra-se que um módulo implica a existência de um ficheiro .h e outro .c com o mesmo nome, devendo o .h conter os tipos de dados e protótipos das funções que serão utilizadas pelos outros módulos e que o ficheiro .c deverá conter o código correspondente a essas funções e outras funções auxiliares que sejam necessárias.</p>
<h2 id="camada-de-dados">Camada de dados</h2>
<p>Esta camada deverá ter a estrutura de dados do programa que deverá ser algo do género:</p>
<pre><code>typedef enum {VAZIO, BRANCA, PRETA} CASA;
typedef struct {
    int coluna;
    int linha;
} COORDENADA;
typedef struct {
    COORDENADA jogador1;
    COORDENADA jogador2;
} JOGADA;
typedef JOGADA JOGADAS[32];
typedef struct {
    CASA tab[8][8];
    COORDENADA ultima_jogada;
    JOGADAS jogadas;
    int num_jogadas;
    int jogador_atual;
} ESTADO;</code></pre>
<p>Em que:</p>
<dl>
    <dt>tab</dt>
    <dd>armazena informação sobre o tabuleiro;
    </dd>
    <dt>ultima_jogada</dt>
    <dd>a coordenada da última jogada
    </dd>
    <dt>jogadas</dt>
    <dd>armazena informação sobre as jogadas
    </dd>
    <dt>num_jogadas</dt>
    <dd>indica quantas jogadas foram efetuadas
    </dd>
    <dt>jogador_atual</dt>
    <dd>indica qual é o jogador a jogar
    </dd>
</dl>
<p>Pretende-se também que crie funções que alterem a estrutura de dados. Todas estas funções devem receber um apontador para ESTADO e modificá-lo. <strong>Só estas funções deverão alterar o estado!</strong> Todo o resto do programa só deverá modificar o estado através destas funções. Segue-se um exemplo dos protótipos das funções que deverão ser criadas (podendo existir outras):</p>
<pre><code>ESTADO *inicializar_estado();
int obter_jogador_atual(ESTADO *estado);
int obter_numero_de_jogadas(ESTADO *estado);
CASA obter_estado_casa(ESTADO *e, COORDENADA c);</code></pre>
<dl>
    <dt>inicializar_estado</dt>
    <dd>Esta função deverá criar um estado vazio (com o tabuleiro inicializado)
    </dd>
    <dt>obter_jogador_atual</dt>
    <dd>Esta função permite obter o número do jogador atual
    </dd>
    <dt>obter_estado_casa</dt>
    <dd>Esta função permite obter o estado atual da casa
    </dd>
    <dt>obter_numero_de_jogadas</dt>
    <dd>Esta função permite obter quantas jogadas foram efetuadas (cada jogada tem o movimento de dois jogadores)
    </dd>
</dl>
<h1 id="lógica-do-programa">Lógica do programa</h1>
<p>Segue-se o exemplo de uma função que trata da lógica do programa:</p>
<pre><code>int jogar(ESTADO *estado, COORDENADA c);</code></pre>
<dl>
    <dt>jogar</dt>
    <dd>esta função deverá receber o estado atual e uma coordenada e modificar o estado ao jogar na casa correta se a jogada for válida. A função devolve <em>verdadeiro</em> (valor diferente de zero) se for possível jogar e <em>falso</em> (zero) caso não seja possível.
    </dd>
</dl>
<h1 id="interface">Interface</h1>
<p>Pretende-se nesta camada ter as funções que tratam do interface:</p>
<li>Conforme o comando a executar, chamar a função correspondente do interface ou da lógica do programa e depois do interface.</li><ul>
    <li>O interpretador de comandos</li>
    <li>A parte que mostra o tabuleiro</li>
</ul>
<h2 id="mostrar-o-tabuleiro">Mostrar o tabuleiro</h2>
<p>Deverá criar-se uma função:</p>
<pre><code>void mostrar_tabuleiro(ESTADO *estado);</code></pre>
<p>Que deverá imprimir o tabuleiro.</p>
<h2 id="interpretador-de-comandos">Interpretador de comandos</h2>
<p>O interpretador de comandos deverá funcionar da seguinte maneira:</p>
<ol type="1">
    <li>Ler uma linha (usando fgets)</li>
    <li>Separar a linha por espaços (por exemplo utilizando sscanf ou strtok)</li>

</ol>
<p>Segue-se um exemplo para poder ser adaptado:</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define BUF_SIZE 1024

// Estruturas de dados (devem ser colocadas no módulo correto da camada dos dados)
    typedef enum {VAZIO, BRANCA, PRETA} CASA;
    typedef struct {
        int coluna;
        int linha;
    } COORDENADA;
    typedef struct {
        COORDENADA jogador1;
        COORDENADA jogador2;
    } JOGADA;
    typedef JOGADA JOGADAS[32];
    typedef struct {
        CASA tab[8][8];
        JOGADAS jogadas;
        int num_jogadas;
        int jogador_atual;
    } ESTADO;

// Função que deve ser completada e colocada na camada da lógica do programa
int jogar(ESTADO *e, COORDENADA c) {
  printf("jogar %d %d\n", c.coluna, c.linha);
  return 1;
}

// Função que deve ser completada e colocada na camada de interface
void mostrar_tabuleiro(ESTADO *e) {
}

// Função que deve ser completada e colocada na camada de dados
ESTADO *inicializar_estado() {
    ESTADO *e = (ESTADO *) malloc(sizeof(ESTADO));
    e-&gt;jogador_atual = 1;
    e-&gt;num_jogadas = 0;
    // Falta a resto da inicialização.
    return e;
}

// Função que deve ser completada e colocada na camada de interface
int interpretador(ESTADO *e) {
        char linha[BUF_SIZE];
        char col[2], lin[2];

        if(fgets(linha, BUF_SIZE, stdin) == NULL)
            return 0;

        if(strlen(linha) == 3 &amp;&amp; sscanf(linha, "%[a-h]%[1-8]", col, lin) == 2) {
            COORDENADA coord = {*col - 'a', *lin - '1'};
            jogar(e, coord);
            mostrar_tabuleiro(e);
        }
    return 1;
}

// Função que deve ser colocada no ficheiro main.c
int main()
{
    ESTADO *e = inicializar_estado();
    interpretador(e);

    return 0;
}</code></pre>


</body></html>